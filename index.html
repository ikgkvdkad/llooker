<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Camera</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            width: 100vw;
            height: 100vh;
        }

        .camera-container {
            display: flex;
            flex-direction: column;
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .camera-row,
        .description-row {
            display: flex;
            width: 100%;
            background: #000;
            align-items: stretch;
            flex: 0 0 50vh;
            height: 50vh;
        }

        .description-row {
            border-top: 1.5px solid rgba(255, 255, 255, 0.3);
        }

        .camera-half {
            position: relative;
            width: 50%;
            height: 100%;
            overflow: hidden;
            background: radial-gradient(circle at center, rgba(36, 38, 62, 0.65), rgba(5, 5, 12, 0.95));
            border: 3px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }

        .camera-half::before,
        .camera-half::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.45);
            pointer-events: none;
            z-index: 600;
            opacity: 0.75;
        }

        .camera-half::before {
            width: 30%;
            height: 2px;
            border-radius: 1px;
        }

        .camera-half::after {
            width: 2px;
            height: 30%;
            border-radius: 1px;
        }

        .camera-half.left {
            border-right-width: 1.5px;
        }

        .camera-half.right {
            border-left-width: 1.5px;
        }

        .camera-filler {
            flex: 1;
            background: #444;
        }

        .description-half {
            position: relative;
            width: 50%;
            height: 100%;
            padding: 20px 18px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            gap: 12px;
            background: rgba(0, 0, 0, 0.85);
            color: rgba(255, 255, 255, 0.9);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-width: 1.5px;
            overflow: hidden;
        }

        .description-half.left {
            border-right-width: 1.5px;
        }

        .description-half.right {
            border-left-width: 1.5px;
        }

        .description-title-button {
            font-size: 18px;
            font-weight: 500;
            letter-spacing: 0.02em;
            color: inherit;
            background: none;
            border: none;
            padding: 0;
            align-self: flex-start;
            text-align: left;
            cursor: pointer;
            border-radius: 6px;
        }

        .description-title-button:hover {
            text-decoration: underline;
        }

        .description-title-button:focus-visible {
            outline: 2px solid rgba(255, 255, 255, 0.7);
            outline-offset: 3px;
            text-decoration: none;
        }

        .description-title-button:active {
            text-decoration: none;
            background: rgba(255, 255, 255, 0.08);
        }

          .description-title-row {
              display: flex;
              align-items: center;
              gap: 10px;
          }

          .description-upload-button {
              font-size: 13px;
              font-weight: 500;
              letter-spacing: 0.01em;
              color: rgba(255, 255, 255, 0.85);
              background: rgba(255, 255, 255, 0.12);
              border: 1px solid rgba(255, 255, 255, 0.25);
              border-radius: 6px;
              padding: 4px 10px;
              cursor: pointer;
              transition: background 0.2s ease, border-color 0.2s ease;
          }

          .description-upload-button:hover {
              background: rgba(255, 255, 255, 0.2);
              border-color: rgba(255, 255, 255, 0.35);
          }

          .description-upload-button:focus-visible {
              outline: 2px solid rgba(255, 255, 255, 0.7);
              outline-offset: 3px;
          }

          .description-upload-button:active {
              background: rgba(255, 255, 255, 0.28);
          }

          .description-upload-input {
              display: none;
          }

        .description-status {
            font-size: 13px;
            line-height: 1.35;
            color: rgba(255, 255, 255, 0.65);
        }

        .description-content {
            font-size: 15px;
            line-height: 1.45;
            white-space: pre-line;
            overflow-y: auto;
            flex: 1 1 auto;
            padding-right: 6px;
            min-height: 0;
            touch-action: pan-y;
            -webkit-overflow-scrolling: touch;
        }

        .description-half.loading .description-status::before {
            content: 'Loadingâ€¦ ';
            font-weight: 400;
            color: rgba(255, 255, 255, 0.75);
        }

        .description-half.error .description-status {
            color: rgba(255, 99, 99, 0.95);
        }

        .description-half.success .description-status {
            color: rgba(112, 255, 166, 0.9);
        }

        .placeholder-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 72px;
            font-weight: 300;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            z-index: 5;
            pointer-events: none;
        }

        .placeholder-text.hidden {
            display: none;
        }

        .video-element {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: none;
            transform-origin: center center;
            position: absolute;
            top: 0;
            left: 0;
        }

        .video-element.active {
            display: block;
        }

        .camera-half.initializing .video-element.active {
            visibility: hidden;
        }
        .captured-photo {
            display: none;
            position: absolute;
            transform-origin: center center;
            object-fit: contain;
            object-position: center;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            will-change: transform;
            box-shadow: 0 18px 48px rgba(0, 0, 0, 0.45);
            transition: transform 0.08s ease-out;
        }

        .captured-photo.active {
            display: block;
        }

        .selection-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 750;
        }

        .selection-box {
            position: absolute;
            border-radius: 22px;
            border: 4px solid rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 0 9999px rgba(5, 5, 12, 0.68);
            background: rgba(255, 255, 255, 0.04);
            pointer-events: auto;
            touch-action: none;
            cursor: grab;
            transition: background 0.18s ease, border-color 0.18s ease;
            user-select: none;
        }

        .selection-box.is-moving {
            cursor: grabbing;
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.95);
        }

        .selection-box.is-resizing {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 1);
        }

        .corner-handle {
            position: absolute;
            width: 46px;
            height: 46px;
            pointer-events: auto;
            touch-action: none;
            user-select: none;
        }

        .corner-handle::before,
        .corner-handle::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.96);
            border-radius: 999px;
        }

        .corner-handle.top-left {
            top: -23px;
            left: -23px;
            cursor: nwse-resize;
        }

        .corner-handle.top-left::before {
            width: 32px;
            height: 6px;
            top: 0;
            left: 0;
        }

        .corner-handle.top-left::after {
            width: 6px;
            height: 32px;
            top: 0;
            left: 0;
        }

        .corner-handle.top-right {
            top: -23px;
            right: -23px;
            cursor: nesw-resize;
        }

        .corner-handle.top-right::before {
            width: 32px;
            height: 6px;
            top: 0;
            right: 0;
        }

        .corner-handle.top-right::after {
            width: 6px;
            height: 32px;
            top: 0;
            right: 0;
        }

        .corner-handle.bottom-left {
            bottom: -23px;
            left: -23px;
            cursor: nesw-resize;
        }

        .corner-handle.bottom-left::before {
            width: 32px;
            height: 6px;
            bottom: 0;
            left: 0;
        }

        .corner-handle.bottom-left::after {
            width: 6px;
            height: 32px;
            bottom: 0;
            left: 0;
        }

        .corner-handle.bottom-right {
            bottom: -23px;
            right: -23px;
            cursor: nwse-resize;
        }

        .corner-handle.bottom-right::before {
            width: 32px;
            height: 6px;
            bottom: 0;
            right: 0;
        }

        .corner-handle.bottom-right::after {
            width: 6px;
            height: 32px;
            bottom: 0;
            right: 0;
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 100;
            max-width: 80%;
        }

        .error-message.active {
            display: block;
        }

        .error-message.warning {
            background: rgba(255, 165, 0, 0.85);
            color: rgba(0, 0, 0, 0.9);
        }

        .version-badge {
            position: absolute;
            bottom: 14px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff4d4d;
            font-size: 14px;
            font-family: 'IBM Plex Mono', 'Courier New', monospace;
            letter-spacing: 0.22em;
            text-transform: uppercase;
            text-shadow: 0 0 6px rgba(255, 77, 77, 0.45);
            pointer-events: none;
            opacity: 0.85;
            z-index: 1500;
        }
    </style>
</head>
<body>
    <div class="camera-container">
            <div class="camera-row">
                <div class="camera-half left" id="backCameraHalf">
                    <div class="placeholder-text" id="backPlaceholder">You</div>
                <video id="backVideoElement" class="video-element" autoplay playsinline></video>
                <img id="backCapturedPhoto" class="captured-photo" alt="Back camera photo">
                <div class="selection-overlay" id="backSelectionOverlay" aria-hidden="true">
                    <div class="selection-box" id="backSelectionBox" role="presentation" aria-hidden="true">
                        <div class="corner-handle top-left" data-handle="top-left" aria-hidden="true"></div>
                        <div class="corner-handle top-right" data-handle="top-right" aria-hidden="true"></div>
                        <div class="corner-handle bottom-left" data-handle="bottom-left" aria-hidden="true"></div>
                        <div class="corner-handle bottom-right" data-handle="bottom-right" aria-hidden="true"></div>
                    </div>
                </div>
            </div>

                <div class="camera-half right" id="selfieCameraHalf">
                    <div class="placeholder-text" id="selfiePlaceholder">Me</div>
                <video id="selfieVideoElement" class="video-element" autoplay playsinline></video>
                <img id="selfieCapturedPhoto" class="captured-photo" alt="Selfie photo">
                <div class="selection-overlay" id="selfieSelectionOverlay" aria-hidden="true">
                    <div class="selection-box" id="selfieSelectionBox" role="presentation" aria-hidden="true">
                        <div class="corner-handle top-left" data-handle="top-left" aria-hidden="true"></div>
                        <div class="corner-handle top-right" data-handle="top-right" aria-hidden="true"></div>
                        <div class="corner-handle bottom-left" data-handle="bottom-left" aria-hidden="true"></div>
                        <div class="corner-handle bottom-right" data-handle="bottom-right" aria-hidden="true"></div>
                    </div>
                </div>
            </div>
        </div>

            <div class="description-row">
                    <div class="description-half left" id="youDescriptionPanel">
                        <div class="description-title-row">
                            <button type="button" class="description-title-button" id="youResubmitButton">You</button>
                            <button type="button" class="description-upload-button" id="youUploadButton">Upload</button>
                            <input type="file" accept="image/*" id="youUploadInput" class="description-upload-input" aria-label="Upload photo for You">
                        </div>
                    <div class="description-status" id="youDescriptionStatus"></div>
                    <div class="description-content" id="youDescriptionContent"></div>
                </div>
                    <div class="description-half right" id="meDescriptionPanel">
                        <div class="description-title-row">
                            <button type="button" class="description-title-button" id="meResubmitButton">Me</button>
                            <button type="button" class="description-upload-button" id="meUploadButton">Upload</button>
                            <input type="file" accept="image/*" id="meUploadInput" class="description-upload-input" aria-label="Upload photo for Me">
                        </div>
                    <div class="description-status" id="meDescriptionStatus"></div>
                    <div class="description-content" id="meDescriptionContent"></div>
                </div>
            </div>

        <div id="versionDisplay" class="version-badge" aria-live="polite"></div>
        <div id="errorMessage" class="error-message"></div>
    </div>

    <script>
        // Back camera elements
        const backVideoElement = document.getElementById('backVideoElement');
        const backCapturedPhoto = document.getElementById('backCapturedPhoto');
        const backCameraHalf = document.getElementById('backCameraHalf');
        const backPlaceholder = document.getElementById('backPlaceholder');
        // Selfie camera elements
        const selfieVideoElement = document.getElementById('selfieVideoElement');
        const selfieCapturedPhoto = document.getElementById('selfieCapturedPhoto');
        const selfieCameraHalf = document.getElementById('selfieCameraHalf');
        const selfiePlaceholder = document.getElementById('selfiePlaceholder');
const backSelectionOverlay = document.getElementById('backSelectionOverlay');
const backSelectionBox = document.getElementById('backSelectionBox');
const selfieSelectionOverlay = document.getElementById('selfieSelectionOverlay');
const selfieSelectionBox = document.getElementById('selfieSelectionBox');
const backSelectionHandles = {
    'top-left': backSelectionBox?.querySelector('.corner-handle.top-left') || null,
    'top-right': backSelectionBox?.querySelector('.corner-handle.top-right') || null,
    'bottom-left': backSelectionBox?.querySelector('.corner-handle.bottom-left') || null,
    'bottom-right': backSelectionBox?.querySelector('.corner-handle.bottom-right') || null
};
const selfieSelectionHandles = {
    'top-left': selfieSelectionBox?.querySelector('.corner-handle.top-left') || null,
    'top-right': selfieSelectionBox?.querySelector('.corner-handle.top-right') || null,
    'bottom-left': selfieSelectionBox?.querySelector('.corner-handle.bottom-left') || null,
    'bottom-right': selfieSelectionBox?.querySelector('.corner-handle.bottom-right') || null
};
        
const DEFAULT_IMAGES = {
    back: 'youphoto.jpg',
    selfie: 'mephoto.jpg'
};

const photoSlots = {
    back: {
        imageEl: backCapturedPhoto,
        placeholderEl: backPlaceholder,
        defaultSrc: DEFAULT_IMAGES.back,
        defaultDescriptionRequested: false,
        lastPhotoDataUrl: null
    },
    selfie: {
        imageEl: selfieCapturedPhoto,
        placeholderEl: selfiePlaceholder,
        defaultSrc: DEFAULT_IMAGES.selfie,
        defaultDescriptionRequested: false,
        lastPhotoDataUrl: null
    }
};

function getPhotoSlotByDescriptionSide(side) {
    if (side === 'you') {
        return photoSlots.back;
    }
    if (side === 'me') {
        return photoSlots.selfie;
    }
    return null;
}

function fetchImageAsDataUrl(src) {
    return fetch(src, { cache: 'no-cache' })
        .then(response => {
            if (!response.ok) {
                throw new Error(`Failed to fetch image ${src}: HTTP ${response.status}`);
            }
            return response.blob();
        })
        .then(blob => new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        }));
}

function requestDefaultDescription(side) {
    const slot = photoSlots[side];
    if (!slot || slot.defaultDescriptionRequested) {
        return;
    }

    const { imageEl, defaultSrc } = slot;
    if (!imageEl || !defaultSrc) {
        return;
    }

    const describe = () => {
        if (slot.defaultDescriptionRequested) {
            return;
        }
        slot.defaultDescriptionRequested = true;
        fetchImageAsDataUrl(defaultSrc)
            .then((dataUrl) => {
                slot.lastPhotoDataUrl = dataUrl;
                const role = side === 'back' ? 'you' : 'me';
                const viewport = snapshotViewportState(side);
                const state = interactionState[side];
                if (state) {
                    state.lastSubmittedSignature = buildViewportSignature(dataUrl, viewport);
                }
                setDescriptionState(role, 'loading', WAITING_FOR_DESCRIPTION_MESSAGE, WAITING_FOR_DESCRIPTION_MESSAGE);
                enqueueDescription(role, dataUrl, viewport, { reason: 'default-photo', force: true });
            })
            .catch(error => {
                console.error(`Failed to describe default ${side} image:`, error);
                slot.defaultDescriptionRequested = false;
            });
    };

    if (imageEl.complete && imageEl.naturalWidth > 0) {
        describe();
        return;
    }

    const handleLoad = () => {
        imageEl.removeEventListener('load', handleLoad);
        imageEl.removeEventListener('error', handleError);
        describe();
    };

    const handleError = (event) => {
        imageEl.removeEventListener('load', handleLoad);
        imageEl.removeEventListener('error', handleError);
        console.error(`Failed to load default ${side} image.`, event?.error || event);
    };

    imageEl.addEventListener('load', handleLoad, { once: true });
    imageEl.addEventListener('error', handleError, { once: true });
}

function showDefaultPhoto(side) {
    const slot = photoSlots[side];
    if (!slot) {
        return;
    }

    const { imageEl, placeholderEl, defaultSrc } = slot;
    if (!imageEl || !defaultSrc) {
        return;
    }

    if (
        imageEl.dataset.defaultPhoto === 'true' &&
        imageEl.classList.contains('active')
    ) {
        if (placeholderEl) {
            placeholderEl.classList.add('hidden');
        }
        resetSelectionRect(side, { notify: false });
        resetPhotoTransform(side);
        const state = interactionState[side];
        if (state) {
            state.lastTap = null;
            state.lastSubmittedSignature = null;
            clearMovementDebounce(side);
        }
        requestDefaultDescription(side);
        return;
    }

    slot.lastPhotoDataUrl = null;
    imageEl.src = defaultSrc;
    imageEl.dataset.defaultPhoto = 'true';
    imageEl.classList.add('active');
    slot.defaultDescriptionRequested = false;
    if (placeholderEl) {
        placeholderEl.classList.add('hidden');
    }
    resetSelectionRect(side, { notify: false });
    resetPhotoTransform(side);
    const state = interactionState[side];
    if (state) {
        state.lastTap = null;
        state.lastSubmittedSignature = null;
        clearMovementDebounce(side);
    }
    requestDefaultDescription(side);
}

function markPhotoCaptured(side) {
    const slot = photoSlots[side];
    if (!slot || !slot.imageEl) {
        return;
    }
    delete slot.imageEl.dataset.defaultPhoto;
    slot.defaultDescriptionRequested = false;
}

function hideDefaultPhoto(side) {
    const slot = photoSlots[side];
    if (!slot || !slot.imageEl) {
        return;
    }
    if (slot.imageEl.dataset.defaultPhoto === 'true') {
        slot.imageEl.classList.remove('active');
    }
}

  function readFileAsDataUrl(file) {
      return new Promise((resolve, reject) => {
          if (!file) {
              reject(new Error('No file provided.'));
              return;
          }

          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = () => reject(reader.error || new Error('Unable to read file.'));
          reader.readAsDataURL(file);
      });
  }

    function displayPhotoForSide(side, dataUrl) {
      if (typeof dataUrl !== 'string' || dataUrl.length === 0) {
          throw new Error('Invalid photo data.');
      }

      const slotKey = side === 'you' ? 'back' : 'selfie';
      const slot = photoSlots[slotKey];

      if (!slot || !slot.imageEl) {
          throw new Error('Photo slot unavailable.');
      }

      markPhotoCaptured(slotKey);
      slot.lastPhotoDataUrl = dataUrl;
      slot.imageEl.src = dataUrl;
      slot.imageEl.classList.add('active');
      delete slot.imageEl.dataset.defaultPhoto;
        resetSelectionRect(slotKey, { notify: false });
        resetPhotoTransform(slotKey);
        const state = interactionState[slotKey];
        if (state) {
            state.lastTap = null;
            state.lastSubmittedSignature = null;
            clearMovementDebounce(slotKey);
        }

      if (slot.placeholderEl) {
          slot.placeholderEl.classList.add('hidden');
      }

      if (slotKey === 'back') {
          backVideoElement.classList.remove('active');
          backPlaceholder.classList.add('hidden');
          backCameraHalf.classList.remove('initializing');
          isBackFrozen = true;
      } else if (slotKey === 'selfie') {
          selfieVideoElement.classList.remove('active');
          selfiePlaceholder.classList.add('hidden');
          isSelfieFrozen = true;
      }
    const schedule = () => scheduleViewportDescription(slotKey, { immediate: true, force: true, reason: 'photo-load' });
    if (slot.imageEl.complete && slot.imageEl.naturalWidth > 0) {
        schedule();
    } else {
        const handleImageLoad = () => {
            slot.imageEl.removeEventListener('load', handleImageLoad);
            schedule();
        };
        slot.imageEl.addEventListener('load', handleImageLoad, { once: true });
    }
  }
        
        const errorMessage = document.getElementById('errorMessage');
        const versionDisplay = document.getElementById('versionDisplay');
          const youDescriptionPanel = document.getElementById('youDescriptionPanel');
          const meDescriptionPanel = document.getElementById('meDescriptionPanel');
          const youDescriptionStatus = document.getElementById('youDescriptionStatus');
          const youDescriptionContent = document.getElementById('youDescriptionContent');
          const meDescriptionStatus = document.getElementById('meDescriptionStatus');
          const meDescriptionContent = document.getElementById('meDescriptionContent');
        const youResubmitButton = document.getElementById('youResubmitButton');
        const meResubmitButton = document.getElementById('meResubmitButton');
        const youUploadButton = document.getElementById('youUploadButton');
        const meUploadButton = document.getElementById('meUploadButton');
        const youUploadInput = document.getElementById('youUploadInput');
        const meUploadInput = document.getElementById('meUploadInput');

        const APP_VERSION = 2;
        const DEFAULT_BACK_ASPECT = 16 / 9;
        const DEFAULT_SELFIE_ASPECT = 16 / 9;
const MIN_SELECTION_EDGE_PX = 140;
const DEFAULT_SELECTION_RECT = Object.freeze({
    x: 0.18,
    y: 0.18,
    width: 0.64,
    height: 0.64
});

        const cameraLayoutState = {
            back: { element: backCameraHalf, aspectRatio: null },
            selfie: { element: selfieCameraHalf, aspectRatio: null }
        };

const selectionElements = {
    back: {
        overlay: backSelectionOverlay,
        box: backSelectionBox,
        handles: backSelectionHandles
    },
    selfie: {
        overlay: selfieSelectionOverlay,
        box: selfieSelectionBox,
        handles: selfieSelectionHandles
    }
};

function createInteractionState() {
    return {
        pointerMap: new Map(),
        baseDistance: null,
        baseZoom: null,
        zoomSupported: false,
        streamZoom: {
            min: 1,
            max: 1,
            current: 1
        },
        transform: {
            scale: 1,
            translateX: 0,
            translateY: 0
        },
        transformBounds: {
            minScale: 1,
            maxScale: 4
        },
        panStart: null,
        tapCandidate: null,
        pendingZoom: null,
        zoomUpdateFrame: null,
        zoomUpdateInFlight: false,
        lastTap: null,
        movementDebounceId: null,
        lastSubmittedSignature: null,
        lastInteractionAt: 0
    };
}

const interactionState = {
    back: createInteractionState(),
    selfie: createInteractionState()
};

function cloneSelectionRect(rect = DEFAULT_SELECTION_RECT) {
    const source = rect || DEFAULT_SELECTION_RECT;
    const safeValue = (value, fallback) =>
        Number.isFinite(value) ? Math.min(1, Math.max(0, value)) : fallback;
    const widthFallback = DEFAULT_SELECTION_RECT.width;
    const heightFallback = DEFAULT_SELECTION_RECT.height;
    let width = safeValue(source.width, widthFallback);
    let height = safeValue(source.height, heightFallback);
    // Prevent degenerate sizes.
    if (width < 0.05) width = widthFallback;
    if (height < 0.05) height = heightFallback;
    return {
        x: safeValue(source.x, DEFAULT_SELECTION_RECT.x),
        y: safeValue(source.y, DEFAULT_SELECTION_RECT.y),
        width,
        height
    };
}

function createSelectionState() {
    return {
        rect: cloneSelectionRect(),
        activePointerId: null,
        mode: null,
        startRect: null,
        startPoint: null,
        activeElement: null,
        lastInteractionAt: 0
    };
}

const selectionState = {
    back: createSelectionState(),
    selfie: createSelectionState()
};

function getSelectionElements(slotKey) {
    return selectionElements[slotKey] || null;
}

function clamp(value, min, max) {
    if (min > max) {
        return min;
    }
    return Math.min(max, Math.max(min, value));
}

function getSelectionMinSize(containerRect) {
    const minWidthRatio = MIN_SELECTION_EDGE_PX > 0 && containerRect?.width
        ? clamp(MIN_SELECTION_EDGE_PX / containerRect.width, 0.12, 0.9)
        : DEFAULT_SELECTION_RECT.width;
    const minHeightRatio = MIN_SELECTION_EDGE_PX > 0 && containerRect?.height
        ? clamp(MIN_SELECTION_EDGE_PX / containerRect.height, 0.12, 0.9)
        : DEFAULT_SELECTION_RECT.height;
    return {
        width: minWidthRatio,
        height: minHeightRatio
    };
}

function clampRectToBounds(rect) {
    if (!rect) {
        return cloneSelectionRect();
    }
    let x = Number.isFinite(rect.x) ? rect.x : DEFAULT_SELECTION_RECT.x;
    let y = Number.isFinite(rect.y) ? rect.y : DEFAULT_SELECTION_RECT.y;
    let width = Number.isFinite(rect.width) ? rect.width : DEFAULT_SELECTION_RECT.width;
    let height = Number.isFinite(rect.height) ? rect.height : DEFAULT_SELECTION_RECT.height;

    x = clamp(x, 0, 1);
    y = clamp(y, 0, 1);
    width = clamp(width, 0.05, 1);
    height = clamp(height, 0.05, 1);

    if (x + width > 1) {
        const overflowX = x + width - 1;
        x = clamp(x - overflowX, 0, 1);
        width = clamp(width - overflowX, 0.05, 1 - x);
    }

    if (y + height > 1) {
        const overflowY = y + height - 1;
        y = clamp(y - overflowY, 0, 1);
        height = clamp(height - overflowY, 0.05, 1 - y);
    }

    return { x, y, width, height };
}

function updateSelectionStyles(slotKey) {
    const state = selectionState[slotKey];
    const elements = getSelectionElements(slotKey);
    if (!state || !elements?.box) {
        return;
    }
    const { x, y, width, height } = clampRectToBounds(state.rect);
    const box = elements.box;
    box.style.left = `${(x * 100).toFixed(3)}%`;
    box.style.top = `${(y * 100).toFixed(3)}%`;
    box.style.width = `${(width * 100).toFixed(3)}%`;
    box.style.height = `${(height * 100).toFixed(3)}%`;
}

function syncSelectionInteractionClasses(slotKey) {
    const state = selectionState[slotKey];
    const elements = getSelectionElements(slotKey);
    if (!state || !elements?.box) {
        return;
    }
    const isMoving = state.mode === 'move' && state.activePointerId !== null;
    const isResizing = state.activePointerId !== null && state.mode && state.mode !== 'move';
    elements.box.classList.toggle('is-moving', isMoving);
    elements.box.classList.toggle('is-resizing', isResizing);
}

function resetSelectionRect(slotKey, { notify = false } = {}) {
    const state = selectionState[slotKey];
    if (!state) {
        return;
    }
    let rect = cloneSelectionRect();
    const container = getCameraHalfElement(slotKey);
    if (container) {
        const bounds = container.getBoundingClientRect();
        if (bounds && Number.isFinite(bounds.width) && Number.isFinite(bounds.height) && bounds.width > 0 && bounds.height > 0) {
            const minSize = getSelectionMinSize(bounds);
            const centerX = rect.x + rect.width / 2;
            const centerY = rect.y + rect.height / 2;
            rect.width = Math.max(rect.width, minSize.width);
            rect.height = Math.max(rect.height, minSize.height);
            rect.width = clamp(rect.width, 0.05, 0.96);
            rect.height = clamp(rect.height, 0.05, 0.96);
            rect.x = clamp(centerX - rect.width / 2, 0, 1 - rect.width);
            rect.y = clamp(centerY - rect.height / 2, 0, 1 - rect.height);
        }
    }
    state.rect = clampRectToBounds(rect);
    updateSelectionStyles(slotKey);
    if (notify) {
        const interaction = interactionState[slotKey];
        if (interaction) {
            interaction.lastSubmittedSignature = null;
            clearMovementDebounce(slotKey);
        }
        scheduleViewportDescription(slotKey, { reason: 'selection-reset', force: true });
    }
}

function getSelectionPointerContext(slotKey, event) {
    const container = getCameraHalfElement(slotKey);
    if (!container) {
        return null;
    }
    const rect = container.getBoundingClientRect();
    if (!rect || !rect.width || !rect.height || !Number.isFinite(rect.width) || !Number.isFinite(rect.height)) {
        return null;
    }
    const relativeX = clamp((event.clientX - rect.left) / rect.width, 0, 1);
    const relativeY = clamp((event.clientY - rect.top) / rect.height, 0, 1);
    return {
        relativeX,
        relativeY,
        containerRect: rect
    };
}

function computeResizedSelectionRect(handle, startRect, point, minSize) {
    const startRight = startRect.x + startRect.width;
    const startBottom = startRect.y + startRect.height;
    let next = { ...startRect };

    if (handle === 'top-left') {
        const newX = clamp(point.x, 0, startRight - minSize.width);
        const newY = clamp(point.y, 0, startBottom - minSize.height);
        next.x = newX;
        next.y = newY;
        next.width = startRight - newX;
        next.height = startBottom - newY;
    } else if (handle === 'top-right') {
        const newRight = clamp(point.x, startRect.x + minSize.width, 1);
        const newTop = clamp(point.y, 0, startBottom - minSize.height);
        next.y = newTop;
        next.width = newRight - startRect.x;
        next.height = startBottom - newTop;
    } else if (handle === 'bottom-left') {
        const newLeft = clamp(point.x, 0, startRight - minSize.width);
        const newBottom = clamp(point.y, startRect.y + minSize.height, 1);
        next.x = newLeft;
        next.width = startRight - newLeft;
        next.height = newBottom - startRect.y;
    } else if (handle === 'bottom-right') {
        const newRight = clamp(point.x, startRect.x + minSize.width, 1);
        const newBottom = clamp(point.y, startRect.y + minSize.height, 1);
        next.width = newRight - startRect.x;
        next.height = newBottom - startRect.y;
    }

    return clampRectToBounds(next);
}

function selectionHasActivePhoto(slotKey) {
    const slot = photoSlots[slotKey];
    if (!slot?.imageEl) {
        return false;
    }
    return slot.imageEl.classList.contains('active');
}

function startSelectionInteraction(slotKey, mode, event) {
    if (event && typeof event.button === 'number' && event.button !== 0 && event.pointerType !== 'touch') {
        return;
    }
    const state = selectionState[slotKey];
    const elements = getSelectionElements(slotKey);
    if (!state || !elements?.box) {
        return;
    }
    if (state.activePointerId !== null && state.activePointerId !== event.pointerId) {
        return;
    }
    const pointerContext = getSelectionPointerContext(slotKey, event);
    if (!pointerContext) {
        console.warn('Selection interaction skipped: container bounds unavailable.');
        return;
    }
    event.preventDefault();
    event.stopPropagation();

    state.activePointerId = event.pointerId;
    state.mode = mode;
    state.startRect = { ...state.rect };
    state.startPoint = { x: pointerContext.relativeX, y: pointerContext.relativeY };
    state.lastInteractionAt = performance.now();
    state.activeElement = event.currentTarget || null;

    if (state.activeElement && typeof state.activeElement.setPointerCapture === 'function') {
        try {
            state.activeElement.setPointerCapture(event.pointerId);
        } catch (captureError) {
            console.warn('Unable to capture pointer for selection interaction:', captureError);
        }
    }

    syncSelectionInteractionClasses(slotKey);
}

function continueSelectionInteraction(slotKey, event) {
    const state = selectionState[slotKey];
    if (!state || state.activePointerId !== event.pointerId || !state.mode || !state.startRect || !state.startPoint) {
        return;
    }

    const pointerContext = getSelectionPointerContext(slotKey, event);
    if (!pointerContext) {
        return;
    }

    event.preventDefault();
    event.stopPropagation();

    const containerRect = pointerContext.containerRect;
    const minSize = getSelectionMinSize(containerRect);
    let nextRect;

    if (state.mode === 'move') {
        const deltaX = pointerContext.relativeX - state.startPoint.x;
        const deltaY = pointerContext.relativeY - state.startPoint.y;
        const maxX = 1 - state.startRect.width;
        const maxY = 1 - state.startRect.height;
        nextRect = {
            x: clamp(state.startRect.x + deltaX, 0, maxX),
            y: clamp(state.startRect.y + deltaY, 0, maxY),
            width: state.startRect.width,
            height: state.startRect.height
        };
    } else {
        nextRect = computeResizedSelectionRect(
            state.mode,
            state.startRect,
            { x: pointerContext.relativeX, y: pointerContext.relativeY },
            minSize
        );
    }

    nextRect = clampRectToBounds(nextRect);

    if (
        Math.abs(nextRect.x - state.rect.x) < 0.0001 &&
        Math.abs(nextRect.y - state.rect.y) < 0.0001 &&
        Math.abs(nextRect.width - state.rect.width) < 0.0001 &&
        Math.abs(nextRect.height - state.rect.height) < 0.0001
    ) {
        return;
    }

    state.rect = nextRect;
    state.lastInteractionAt = performance.now();
    updateSelectionStyles(slotKey);

    if (selectionHasActivePhoto(slotKey)) {
        scheduleViewportDescription(slotKey, { reason: 'selection-change' });
    }
}

function finishSelectionInteraction(slotKey, event) {
    const state = selectionState[slotKey];
    if (!state || state.activePointerId !== event.pointerId) {
        return;
    }

    event.preventDefault();
    event.stopPropagation();

    if (state.activeElement && typeof state.activeElement.releasePointerCapture === 'function') {
        try {
            state.activeElement.releasePointerCapture(event.pointerId);
        } catch (releaseError) {
            // Ignore release errors.
        }
    }

    state.activePointerId = null;
    state.mode = null;
    state.startRect = null;
    state.startPoint = null;
    state.activeElement = null;

    syncSelectionInteractionClasses(slotKey);

    if (selectionHasActivePhoto(slotKey)) {
        scheduleViewportDescription(slotKey, { reason: 'selection-release', immediate: true });
    }
}

function setupSelectionInteractions(slotKey) {
    const elements = getSelectionElements(slotKey);
    if (!elements?.box) {
        return;
    }

    const box = elements.box;

    const handleBoxPointerDown = (event) => {
        if (event.target !== box) {
            return;
        }
        startSelectionInteraction(slotKey, 'move', event);
    };

    box.addEventListener('pointerdown', handleBoxPointerDown);
    box.addEventListener('pointermove', (event) => continueSelectionInteraction(slotKey, event));
    box.addEventListener('pointerup', (event) => finishSelectionInteraction(slotKey, event));
    box.addEventListener('pointercancel', (event) => finishSelectionInteraction(slotKey, event));

    Object.entries(elements.handles || {}).forEach(([handleKey, handleElement]) => {
        if (!handleElement) {
            return;
        }
        handleElement.addEventListener('pointerdown', (event) => {
            startSelectionInteraction(slotKey, handleKey, event);
        });
        handleElement.addEventListener('pointermove', (event) => continueSelectionInteraction(slotKey, event));
        handleElement.addEventListener('pointerup', (event) => finishSelectionInteraction(slotKey, event));
        handleElement.addEventListener('pointercancel', (event) => finishSelectionInteraction(slotKey, event));
    });
}

function isCameraActive(slotKey) {
    if (slotKey === 'back') {
        return isBackActive;
    }
    if (slotKey === 'selfie') {
        return isSelfieActive;
    }
    return false;
}

function isCameraFrozen(slotKey) {
    if (slotKey === 'back') {
        return isBackFrozen;
    }
    if (slotKey === 'selfie') {
        return isSelfieFrozen;
    }
    return false;
}

function getCameraHalfElement(slotKey) {
    if (slotKey === 'back') {
        return backCameraHalf;
    }
    if (slotKey === 'selfie') {
        return selfieCameraHalf;
    }
    return null;
}

function snapshotViewportState(slotKey) {
    const slot = photoSlots[slotKey];
    const state = interactionState[slotKey];
    const container = getCameraHalfElement(slotKey);
    if (!slot || !state || !slot?.imageEl || !container) {
        return null;
    }

    const rect = container.getBoundingClientRect();
    const containerWidth = rect?.width;
    const containerHeight = rect?.height;
    const naturalWidth = slot.imageEl.naturalWidth || slot.imageEl.videoWidth || slot.imageEl.width;
    const naturalHeight = slot.imageEl.naturalHeight || slot.imageEl.videoHeight || slot.imageEl.height;

    if (
        !containerWidth ||
        !containerHeight ||
        !naturalWidth ||
        !naturalHeight ||
        !Number.isFinite(containerWidth) ||
        !Number.isFinite(containerHeight)
    ) {
        return null;
    }

    const computedStyle = window.getComputedStyle(slot.imageEl);
    const objectFit = computedStyle?.objectFit || 'cover';
    const transformScale = Number.isFinite(state.transform?.scale) ? state.transform.scale : 1;
    const transformTranslateX = Number.isFinite(state.transform?.translateX) ? state.transform.translateX : 0;
    const transformTranslateY = Number.isFinite(state.transform?.translateY) ? state.transform.translateY : 0;
    const selectionRect = selectionState[slotKey]?.rect
        ? clampRectToBounds(selectionState[slotKey].rect)
        : null;

    return {
        containerWidth,
        containerHeight,
        naturalWidth,
        naturalHeight,
        objectFit,
        transform: {
            scale: Math.max(0.01, transformScale),
            translateX: transformTranslateX,
            translateY: transformTranslateY
        },
        devicePixelRatio: window.devicePixelRatio && Number.isFinite(window.devicePixelRatio)
            ? Math.max(1, window.devicePixelRatio)
            : 1,
        selection: selectionRect ? { ...selectionRect } : null
    };
}

function resetPhotoTransform(slotKey) {
    const state = interactionState[slotKey];
    const slot = photoSlots[slotKey];
    if (!state || !slot?.imageEl) {
        return;
    }
    state.transform.scale = 1;
    state.transform.translateX = 0;
    state.transform.translateY = 0;
    applyPhotoTransform(slotKey);
}

function clampPhotoTranslation(slotKey) {
    const state = interactionState[slotKey];
    const slot = photoSlots[slotKey];
    const container = getCameraHalfElement(slotKey);
    if (!state || !slot?.imageEl || !container) {
        return;
    }

    const { scale } = state.transform;
    const boundsWidth = container.clientWidth;
    const boundsHeight = container.clientHeight;
    if (!boundsWidth || !boundsHeight) {
        return;
    }

    const overflowX = Math.max(0, ((scale - 1) * boundsWidth) / 2);
    const overflowY = Math.max(0, ((scale - 1) * boundsHeight) / 2);
    const freeTravelX = boundsWidth * 0.75;
    const freeTravelY = boundsHeight * 0.75;

    const maxOffsetX = overflowX + freeTravelX;
    const maxOffsetY = overflowY + freeTravelY;

    state.transform.translateX = Math.min(
        Math.max(state.transform.translateX, -maxOffsetX),
        maxOffsetX
    );

    state.transform.translateY = Math.min(
        Math.max(state.transform.translateY, -maxOffsetY),
        maxOffsetY
    );
}

function applyPhotoTransform(slotKey) {
    const slot = photoSlots[slotKey];
    const state = interactionState[slotKey];
    if (!slot?.imageEl || !state) {
        return;
    }

    clampPhotoTranslation(slotKey);
    const { scale, translateX, translateY } = state.transform;
    slot.imageEl.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
}

const DESCRIPTION_MOVEMENT_DEBOUNCE_MS = 2000;

function clearMovementDebounce(slotKey) {
    const state = interactionState[slotKey];
    if (!state) {
        return;
    }
    if (state.movementDebounceId !== null) {
        window.clearTimeout(state.movementDebounceId);
        state.movementDebounceId = null;
    }
}

function buildViewportSignature(photoDataUrl, viewportSnapshot) {
    if (typeof photoDataUrl !== 'string' || !photoDataUrl.length || !viewportSnapshot) {
        return null;
    }
    const { containerWidth, containerHeight, naturalWidth, naturalHeight, transform, selection } = viewportSnapshot;
    const parts = [
        containerWidth && Number.isFinite(containerWidth) ? containerWidth.toFixed(1) : 'cw',
        containerHeight && Number.isFinite(containerHeight) ? containerHeight.toFixed(1) : 'ch',
        naturalWidth && Number.isFinite(naturalWidth) ? naturalWidth.toFixed(1) : 'nw',
        naturalHeight && Number.isFinite(naturalHeight) ? naturalHeight.toFixed(1) : 'nh',
        transform && Number.isFinite(transform.scale) ? transform.scale.toFixed(3) : 's',
        transform && Number.isFinite(transform.translateX) ? transform.translateX.toFixed(1) : 'tx',
        transform && Number.isFinite(transform.translateY) ? transform.translateY.toFixed(1) : 'ty'
    ];
    if (selection) {
        parts.push(
            Number.isFinite(selection.x) ? selection.x.toFixed(4) : 'sx',
            Number.isFinite(selection.y) ? selection.y.toFixed(4) : 'sy',
            Number.isFinite(selection.width) ? selection.width.toFixed(4) : 'sw',
            Number.isFinite(selection.height) ? selection.height.toFixed(4) : 'sh'
        );
    } else {
        parts.push('sx', 'sy', 'sw', 'sh');
    }
    const prefix = photoDataUrl.length > 64 ? photoDataUrl.slice(0, 64) : photoDataUrl;
    return `${prefix}|${parts.join('|')}`;
}

function submitViewportDescription(slotKey, { force = false, reason = 'interaction' } = {}) {
    const slot = photoSlots[slotKey];
    const state = interactionState[slotKey];
    if (!slot || !state) {
        return;
    }

    const photoDataUrl = slot.lastPhotoDataUrl;
    if (typeof photoDataUrl !== 'string' || !photoDataUrl.length) {
        return;
    }

    const side = slotKey === 'back' ? 'you' : 'me';
    const viewport = snapshotViewportState(slotKey);
    if (!viewport) {
        return;
    }

    const signature = buildViewportSignature(photoDataUrl, viewport);
    if (!force && signature && state.lastSubmittedSignature === signature) {
        return;
    }

    state.lastSubmittedSignature = signature;
    const label = side === 'you' ? 'You' : 'Me';
    setDescriptionState(side, 'loading', WAITING_FOR_DESCRIPTION_MESSAGE, WAITING_FOR_DESCRIPTION_MESSAGE);
    enqueueDescription(side, photoDataUrl, viewport, { reason, signature });
}

function scheduleViewportDescription(slotKey, options = {}) {
    const state = interactionState[slotKey];
    if (!state) {
        return;
    }
    clearMovementDebounce(slotKey);
    const delay = options.immediate ? 0 : DESCRIPTION_MOVEMENT_DEBOUNCE_MS;
    state.movementDebounceId = window.setTimeout(() => {
        state.movementDebounceId = null;
        submitViewportDescription(slotKey, {
            force: options.force === true,
            reason: options.reason || 'interaction'
        });
    }, delay);
}

function resetPointerTracking(slotKey) {
    const state = interactionState[slotKey];
    if (!state) {
        return;
    }
    state.pointerMap.clear();
    state.baseDistance = null;
    state.baseZoom = null;
    state.panStart = null;
    state.tapCandidate = null;
    state.pendingZoom = null;
    if (state.zoomUpdateFrame !== null) {
        cancelAnimationFrame(state.zoomUpdateFrame);
        state.zoomUpdateFrame = null;
    }
    state.zoomUpdateInFlight = false;
    state.lastTap = null;
    clearMovementDebounce(slotKey);
}

function calculateDistance(pointerA, pointerB) {
    if (!pointerA || !pointerB) {
        return 0;
    }
    const deltaX = pointerB.clientX - pointerA.clientX;
    const deltaY = pointerB.clientY - pointerA.clientY;
    return Math.hypot(deltaX, deltaY);
}

function getPointerEntries(state) {
    if (!state) {
        return [];
    }
    return Array.from(state.pointerMap.values());
}

function addPointer(state, event) {
    state.pointerMap.set(event.pointerId, {
        pointerId: event.pointerId,
        clientX: event.clientX,
        clientY: event.clientY,
        startX: event.clientX,
        startY: event.clientY
    });
}

function updatePointer(state, event) {
    const entry = state.pointerMap.get(event.pointerId);
    if (!entry) {
        return;
    }
    entry.clientX = event.clientX;
    entry.clientY = event.clientY;
}

function removePointer(state, pointerId) {
    if (!state) {
        return;
    }
    state.pointerMap.delete(pointerId);
}

function initializeZoomStateFromTrack(slotKey, track) {
    const state = interactionState[slotKey];
    if (!state || !track) {
        return;
    }

    let capabilities = null;
    let settings = null;

    if (typeof track.getCapabilities === 'function') {
        capabilities = track.getCapabilities();
    }
    if (typeof track.getSettings === 'function') {
        settings = track.getSettings();
    }

    const zoomCapabilities = capabilities?.zoom;
    if (zoomCapabilities && typeof zoomCapabilities.min === 'number' && typeof zoomCapabilities.max === 'number') {
        state.zoomSupported = true;
        state.streamZoom.min = zoomCapabilities.min;
        state.streamZoom.max = zoomCapabilities.max;
    } else {
        state.zoomSupported = false;
        state.streamZoom.min = 1;
        state.streamZoom.max = 1;
    }

    if (typeof settings?.zoom === 'number') {
        state.streamZoom.current = settings.zoom;
    } else if (state.zoomSupported) {
        state.streamZoom.current = state.streamZoom.min;
    } else {
        state.streamZoom.current = 1;
    }
}

function scheduleCameraZoomUpdate(slotKey, targetZoom) {
    const state = interactionState[slotKey];
    if (!state) {
        return;
    }

    const clamped = Math.min(state.streamZoom.max, Math.max(state.streamZoom.min, targetZoom));
    state.pendingZoom = clamped;

    if (state.zoomUpdateFrame !== null) {
        return;
    }

    state.zoomUpdateFrame = requestAnimationFrame(() => {
        state.zoomUpdateFrame = null;
        if (state.zoomUpdateInFlight) {
            scheduleCameraZoomUpdate(slotKey, state.pendingZoom);
            return;
        }
        if (typeof state.pendingZoom === 'number') {
            applyStreamZoom(slotKey, state.pendingZoom);
        }
    });
}

async function applyStreamZoom(slotKey, targetZoom) {
    const state = interactionState[slotKey];
    if (!state) {
        return;
    }

    const stream = slotKey === 'back' ? backStream : selfieStream;
    const track = stream?.getVideoTracks?.()[0];
    if (!track) {
        return;
    }

    state.zoomUpdateInFlight = true;

    try {
        await track.applyConstraints({ advanced: [{ zoom: targetZoom }] });
        state.streamZoom.current = targetZoom;
    } catch (primaryError) {
        try {
            await track.applyConstraints({ zoom: targetZoom });
            state.streamZoom.current = targetZoom;
        } catch (secondaryError) {
            console.warn('Unable to apply pinch zoom:', secondaryError || primaryError);
            state.zoomSupported = false;
        }
    } finally {
        state.zoomUpdateInFlight = false;
        const pending = state.pendingZoom;
        state.pendingZoom = null;
        if (typeof pending === 'number' && Math.abs(pending - targetZoom) > 0.01) {
            scheduleCameraZoomUpdate(slotKey, pending);
        }
    }
}

function handlePointerDownOnHalf(slotKey, event) {
    const state = interactionState[slotKey];
    if (!state) {
        return;
    }

    event.preventDefault();

    const target = event.currentTarget;
    if (target && typeof target.setPointerCapture === 'function') {
        try {
            target.setPointerCapture(event.pointerId);
        } catch (captureError) {
            console.warn('Failed to set pointer capture:', captureError);
        }
    }

    addPointer(state, event);

    if (state.pointerMap.size === 1) {
        state.baseDistance = null;
        state.baseZoom = null;
        state.tapCandidate = {
            pointerId: event.pointerId,
            startX: event.clientX,
            startY: event.clientY,
            startTime: performance.now()
        };

        if (isCameraFrozen(slotKey)) {
            state.panStart = {
                pointerId: event.pointerId,
                startX: event.clientX,
                startY: event.clientY,
                originX: state.transform.translateX,
                originY: state.transform.translateY
            };
        } else {
            state.panStart = null;
        }
    } else if (state.pointerMap.size === 2) {
        const pointers = getPointerEntries(state);
        state.baseDistance = calculateDistance(pointers[0], pointers[1]);
        if (state.baseDistance < 0.01) {
            state.baseDistance = 0;
        }

        if (isCameraActive(slotKey) && state.zoomSupported) {
            state.baseZoom = state.streamZoom.current || state.streamZoom.min || 1;
        } else if (isCameraFrozen(slotKey)) {
            state.baseZoom = state.transform.scale || 1;
        } else {
            state.baseZoom = null;
        }

        state.tapCandidate = null;
        state.panStart = null;
    } else {
        state.tapCandidate = null;
        state.panStart = null;
        state.baseDistance = null;
        state.baseZoom = null;
    }
}

function handlePointerMoveOnHalf(slotKey, event) {
    const state = interactionState[slotKey];
    if (!state) {
        return;
    }

    updatePointer(state, event);
    let viewportChanged = false;

    if (state.pointerMap.size === 2 && state.baseDistance) {
        const pointers = getPointerEntries(state);
        const distance = calculateDistance(pointers[0], pointers[1]);
        if (distance > 0 && state.baseDistance > 0) {
            const scaleFactor = distance / state.baseDistance;

            if (isCameraActive(slotKey) && state.zoomSupported && state.baseZoom) {
                const targetZoom = state.baseZoom * scaleFactor;
                scheduleCameraZoomUpdate(slotKey, targetZoom);
            } else if (isCameraFrozen(slotKey)) {
                const baseScale = state.baseZoom || 1;
                let targetScale = baseScale * scaleFactor;
                targetScale = Math.min(state.transformBounds.maxScale, Math.max(1, targetScale));
                if (Math.abs(targetScale - state.transform.scale) > 0.005) {
                    state.transform.scale = targetScale;
                    applyPhotoTransform(slotKey);
                    viewportChanged = true;
                }
            }
        }
        state.tapCandidate = null;
    } else if (
        state.pointerMap.size === 1 &&
        state.panStart &&
        state.panStart.pointerId === event.pointerId &&
        isCameraFrozen(slotKey)
    ) {
        const deltaX = event.clientX - state.panStart.startX;
        const deltaY = event.clientY - state.panStart.startY;
        state.transform.translateX = state.panStart.originX + deltaX;
        state.transform.translateY = state.panStart.originY + deltaY;
        applyPhotoTransform(slotKey);
        viewportChanged = true;
    }

    if (state.tapCandidate && state.tapCandidate.pointerId === event.pointerId) {
        const dx = event.clientX - state.tapCandidate.startX;
        const dy = event.clientY - state.tapCandidate.startY;
        if (Math.hypot(dx, dy) > TAP_MAX_MOVEMENT_PX) {
            state.tapCandidate = null;
        }
    }

    if (viewportChanged) {
        state.lastInteractionAt = performance.now();
        scheduleViewportDescription(slotKey, { reason: 'interaction' });
    }
}

function handlePointerUpOnHalf(slotKey, event) {
    const state = interactionState[slotKey];
    if (!state) {
        return;
    }

    const target = event.currentTarget;
    if (target && typeof target.releasePointerCapture === 'function') {
        try {
            target.releasePointerCapture(event.pointerId);
        } catch (releaseError) {
            // Ignore release errors
        }
    }

    let isTap = false;
    if (state.tapCandidate && state.tapCandidate.pointerId === event.pointerId) {
        const duration = performance.now() - state.tapCandidate.startTime;
        const dx = event.clientX - state.tapCandidate.startX;
        const dy = event.clientY - state.tapCandidate.startY;
        if (duration <= TAP_MAX_DURATION_MS && Math.hypot(dx, dy) <= TAP_MAX_MOVEMENT_PX) {
            isTap = true;
        }
    }

    removePointer(state, event.pointerId);

    state.tapCandidate = null;

    if (state.pointerMap.size === 0) {
        state.baseDistance = null;
        state.baseZoom = null;
        state.panStart = null;
    } else if (state.pointerMap.size === 1 && isCameraFrozen(slotKey)) {
        const [remainingPointer] = getPointerEntries(state);
        state.panStart = {
            pointerId: remainingPointer.pointerId,
            startX: remainingPointer.clientX,
            startY: remainingPointer.clientY,
            originX: state.transform.translateX,
            originY: state.transform.translateY
        };
        state.baseDistance = null;
        state.baseZoom = null;
    } else {
        state.baseDistance = null;
        state.baseZoom = null;
        state.panStart = null;
    }

    if (isTap) {
        handleTapOnHalf(slotKey, event);
    }
}

function handlePointerCancelOnHalf(slotKey, event) {
    const state = interactionState[slotKey];
    if (!state) {
        return;
    }

    removePointer(state, event.pointerId);
    state.tapCandidate = null;
    if (state.pointerMap.size === 0) {
        state.baseDistance = null;
        state.baseZoom = null;
        state.panStart = null;
    } else if (state.pointerMap.size === 1 && isCameraFrozen(slotKey)) {
        const [remainingPointer] = getPointerEntries(state);
        state.panStart = {
            pointerId: remainingPointer.pointerId,
            startX: remainingPointer.clientX,
            startY: remainingPointer.clientY,
            originX: state.transform.translateX,
            originY: state.transform.translateY
        };
        state.baseDistance = null;
        state.baseZoom = null;
    } else {
        state.baseDistance = null;
        state.baseZoom = null;
        state.panStart = null;
    }
}

function handleTapOnHalf(slotKey, event) {
    const state = interactionState[slotKey];
    if (!state) {
        return;
    }

    const now = performance.now();
    const isFrozen = isCameraFrozen(slotKey);
    const isActive = isCameraActive(slotKey);

    if (isFrozen) {
        const lastTap = state.lastTap;
        const isDoubleTap =
            lastTap &&
            now - lastTap.time < 400 &&
            Math.hypot(
                event.clientX - lastTap.clientX,
                event.clientY - lastTap.clientY
            ) < 48;

        state.lastTap = { time: now, clientX: event.clientX, clientY: event.clientY };

        if (isDoubleTap) {
            if (slotKey === 'back') {
                resetBackCamera();
                openBackCamera().catch(error => console.error('Failed to reopen back camera:', error));
            } else if (slotKey === 'selfie') {
                resetSelfieCamera();
                openSelfieCamera().catch(error => console.error('Failed to reopen selfie camera:', error));
            }
            return;
        }

        submitViewportDescription(slotKey, { force: true, reason: 'tap' });
        return;
    }

    state.lastTap = { time: now, clientX: event.clientX, clientY: event.clientY };

    if (isActive) {
        if (slotKey === 'back') {
            captureBackPhoto();
        } else if (slotKey === 'selfie') {
            captureSelfiePhoto();
        }
        return;
    }

    if (slotKey === 'back') {
        openBackCamera().catch(error => console.error('Failed to open back camera:', error));
    } else if (slotKey === 'selfie') {
        openSelfieCamera().catch(error => console.error('Failed to open selfie camera:', error));
    }
}
        function updateCameraHalfAspect(side, aspectRatio) {
            const state = cameraLayoutState[side];
            if (!state || !state.element) {
                return;
            }

            if (typeof aspectRatio === 'number' && isFinite(aspectRatio) && aspectRatio > 0) {
                state.aspectRatio = aspectRatio;
                state.element.dataset.cameraAspect = aspectRatio.toString();
                state.element.style.setProperty('--camera-aspect', aspectRatio);
            } else {
                state.aspectRatio = null;
                delete state.element.dataset.cameraAspect;
                state.element.style.removeProperty('--camera-aspect');
            }
        }

        updateCameraHalfAspect('back', DEFAULT_BACK_ASPECT);
        updateCameraHalfAspect('selfie', DEFAULT_SELFIE_ASPECT);

showDefaultPhoto('back');
showDefaultPhoto('selfie');
        
        // Back camera state
        const BACK_TARGET_ZOOM = 2;
        const SELFIE_ZOOM_MODE = 'min';
          const DESCRIPTION_API_TIMEOUT_MS = 25000;
            const descriptionQueue = [];
          let isDescriptionInFlight = false;
          const descriptionState = {
              you: {
                  panel: youDescriptionPanel,
                  statusEl: youDescriptionStatus,
                  contentEl: youDescriptionContent
              },
              me: {
                  panel: meDescriptionPanel,
                  statusEl: meDescriptionStatus,
                  contentEl: meDescriptionContent
              }
          };
            const WAITING_FOR_DESCRIPTION_MESSAGE = 'Analyzing the framed subject... adjust the photo and hold steady to refresh.';
          const TAP_MAX_MOVEMENT_PX = 12;
          const TAP_MAX_DURATION_MS = 350;

          function resetDescriptionState(side) {
              const state = descriptionState[side];
              if (!state) return;
              state.panel.classList.remove('loading', 'error', 'success');
              state.statusEl.textContent = side === 'you'
                    ? 'Waiting for a You capture. Capture or upload a photo, then pan and zoom to center the subject.'
                    : 'Waiting for a Me capture. Capture or upload your selfie, then center yourself in the frame.';
              state.contentEl.textContent = '';
          }

          function setDescriptionState(side, status, message, descriptionText = '') {
              const state = descriptionState[side];
              if (!state) return;
              state.panel.classList.remove('loading', 'error', 'success');
              if (status === 'loading') {
                  state.panel.classList.add('loading');
              } else if (status === 'error') {
                  state.panel.classList.add('error');
              } else if (status === 'success') {
                  state.panel.classList.add('success');
              }
              if (typeof message === 'string') {
                  state.statusEl.textContent = message;
              }
              state.contentEl.textContent = descriptionText;
          }

            function handleResubmitDescription(side) {
                const slot = getPhotoSlotByDescriptionSide(side);
                const label = side === 'you' ? 'You' : 'Me';

                if (!slot) {
                    console.warn(`No photo slot available for ${side} resubmission request.`);
                    return;
                }

                const photoDataUrl = slot.lastPhotoDataUrl;
                const hasActivePhoto = !!(slot.imageEl && slot.imageEl.classList.contains('active'));

                if (!photoDataUrl) {
                    const message = hasActivePhoto
                        ? `${label} photo data is still loading. Try again shortly or capture a new photo.`
                        : `${label} photo not captured yet. Capture a photo before requesting a description.`;
                    setDescriptionState(side, 'error', message);
                    return;
                }

                const slotKey = side === 'you' ? 'back' : 'selfie';
                const interaction = interactionState[slotKey];
                if (interaction) {
                    interaction.lastSubmittedSignature = null;
                    clearMovementDebounce(slotKey);
                }

                const submit = () => submitViewportDescription(slotKey, { force: true, reason: 'resubmit' });

                if (slot.imageEl && slot.imageEl.complete && slot.imageEl.naturalWidth > 0) {
                    submit();
                } else if (slot.imageEl) {
                    const handleLoad = () => {
                        slot.imageEl.removeEventListener('load', handleLoad);
                        submit();
                    };
                    slot.imageEl.addEventListener('load', handleLoad, { once: true });
                } else {
                    submit();
                }
            }

            function attachResubmitHandlers(button, side) {
                if (!button) {
                    return;
                }
                button.addEventListener('click', () => handleResubmitDescription(side));
                button.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                    handleResubmitDescription(side);
                }, { passive: false });
            }
  
            function attachUploadHandler(button, input, side) {
                if (!button || !input) {
                    return;
                }

                const triggerInputSelection = () => {
                    input.click();
                };

                let suppressNextClick = false;
                let suppressTimerId = null;

                const clearSuppressTimer = () => {
                    if (suppressTimerId !== null) {
                        window.clearTimeout(suppressTimerId);
                        suppressTimerId = null;
                    }
                };

                button.addEventListener('click', (event) => {
                    if (suppressNextClick) {
                        suppressNextClick = false;
                        clearSuppressTimer();
                        return;
                    }
                    triggerInputSelection();
                });

                button.addEventListener('pointerup', (event) => {
                    if (event.pointerType === 'touch') {
                        event.preventDefault();
                        suppressNextClick = true;
                        clearSuppressTimer();
                        suppressTimerId = window.setTimeout(() => {
                            suppressNextClick = false;
                            suppressTimerId = null;
                        }, 300);
                        triggerInputSelection();
                    }
                });

                input.addEventListener('change', async () => {
                  const file = input.files && input.files[0];
                  if (!file) {
                      return;
                  }

                  const label = side === 'you' ? 'You' : 'Me';

                  if (file.type && !file.type.startsWith('image/')) {
                      const message = `${label} upload failed: selected file is not an image.`;
                      console.warn(message);
                      showError(message);
                      setDescriptionState(side, 'error', message);
                      input.value = '';
                      return;
                  }

                    try {
                      const dataUrl = await readFileAsDataUrl(file);
                      if (typeof dataUrl !== 'string') {
                          throw new Error('Uploaded data unavailable.');
                      }
                      displayPhotoForSide(side, dataUrl);
                      stopAllCameras();
                      hideError();
                  } catch (error) {
                      console.error(`${label} photo upload failed:`, error);
                      const message = `${label} upload failed: ${error?.message || 'Unable to process image.'}`;
                      showError(message);
                      setDescriptionState(side, 'error', message);
                  } finally {
                      input.value = '';
                  }
              });
          }

            function loadImageElement(dataUrl) {
                return new Promise((resolve, reject) => {
                    const image = new Image();
                    image.decoding = 'async';
                    image.onload = () => resolve(image);
                    image.onerror = () => reject(new Error('Failed to load photo data for rendering.'));
                    image.src = dataUrl;
                });
            }

    async function createViewportDataUrl(photoDataUrl, viewportSnapshot) {
        if (typeof photoDataUrl !== 'string' || photoDataUrl.length === 0) {
            throw new Error('Photo data unavailable.');
        }

        const image = await loadImageElement(photoDataUrl);
        const naturalWidth = image.naturalWidth || image.width;
        const naturalHeight = image.naturalHeight || image.height;

        if (!naturalWidth || !naturalHeight) {
            throw new Error('Photo dimensions unavailable.');
        }

        if (
            !viewportSnapshot ||
            !Number.isFinite(viewportSnapshot.containerWidth) ||
            !Number.isFinite(viewportSnapshot.containerHeight) ||
            viewportSnapshot.containerWidth <= 0 ||
            viewportSnapshot.containerHeight <= 0
        ) {
            const error = new Error('Viewport geometry missing.');
            error.name = 'ViewportNotReadyError';
            throw error;
        }

        const containerWidth = viewportSnapshot.containerWidth;
        const containerHeight = viewportSnapshot.containerHeight;
        const selectionInput = viewportSnapshot.selection;

        if (
            !selectionInput ||
            !Number.isFinite(selectionInput.x) ||
            !Number.isFinite(selectionInput.y) ||
            !Number.isFinite(selectionInput.width) ||
            !Number.isFinite(selectionInput.height) ||
            selectionInput.width <= 0 ||
            selectionInput.height <= 0
        ) {
            const error = new Error('Selection area missing or invalid.');
            error.name = 'SelectionAreaError';
            throw error;
        }

        const selection = clampRectToBounds(selectionInput);
        const selectionWidthPx = selection.width * containerWidth;
        const selectionHeightPx = selection.height * containerHeight;

        if (selectionWidthPx < 2 || selectionHeightPx < 2) {
            const error = new Error('Selection area is too small to analyze.');
            error.name = 'SelectionAreaError';
            throw error;
        }

        const devicePixelRatio = Number.isFinite(viewportSnapshot.devicePixelRatio)
            ? Math.max(1, viewportSnapshot.devicePixelRatio)
            : 1;
        const objectFit = (viewportSnapshot.objectFit || 'cover').toLowerCase();
        const transform = viewportSnapshot.transform || {};
        const userScale = Number.isFinite(transform.scale) ? Math.max(0.01, transform.scale) : 1;
        const translateX = Number.isFinite(transform.translateX) ? transform.translateX : 0;
        const translateY = Number.isFinite(transform.translateY) ? transform.translateY : 0;

        let baseScale;
        if (objectFit === 'contain') {
            baseScale = Math.min(containerWidth / naturalWidth, containerHeight / naturalHeight);
        } else {
            baseScale = Math.max(containerWidth / naturalWidth, containerHeight / naturalHeight);
        }

        if (!Number.isFinite(baseScale) || baseScale <= 0) {
            const error = new Error('Viewport scale unavailable.');
            error.name = 'ViewportScaleError';
            throw error;
        }

        const finalScale = baseScale * userScale;
        const canvas = document.createElement('canvas');
        canvas.width = Math.max(1, Math.round(selectionWidthPx * devicePixelRatio));
        canvas.height = Math.max(1, Math.round(selectionHeightPx * devicePixelRatio));
        const ctx = canvas.getContext('2d');

        if (!ctx) {
            throw new Error('Canvas context unavailable for rendering.');
        }

        ctx.scale(devicePixelRatio, devicePixelRatio);
        ctx.fillStyle = '#05050c';
        ctx.fillRect(0, 0, selectionWidthPx, selectionHeightPx);
        ctx.imageSmoothingQuality = 'high';

        ctx.save();
        ctx.translate(-selection.x * containerWidth, -selection.y * containerHeight);
        ctx.translate(containerWidth / 2, containerHeight / 2);
        ctx.translate(translateX, translateY);
        ctx.scale(finalScale, finalScale);
        ctx.drawImage(
            image,
            -naturalWidth / 2,
            -naturalHeight / 2,
            naturalWidth,
            naturalHeight
        );
        ctx.restore();

        return canvas.toDataURL('image/png');
    }

            function enqueueDescription(side, photoDataUrl, viewportSnapshot = null, options = {}) {
              const slot = getPhotoSlotByDescriptionSide(side);
              if (slot && typeof photoDataUrl === 'string' && photoDataUrl.length > 0) {
                  slot.lastPhotoDataUrl = photoDataUrl;
              }
                descriptionQueue.push({ side, photoDataUrl, viewport: viewportSnapshot, options });
              processDescriptionQueue();
          }

            function processDescriptionQueue() {
                if (isDescriptionInFlight) {
                    return;
                }
  
                const next = descriptionQueue.shift();
                if (!next) {
                    return;
                }
  
                isDescriptionInFlight = true;
                requestDescription(next.side, next.photoDataUrl, next.viewport, next.options)
                  .catch(error => {
                      console.error('Description request failed:', error);
                  })
                  .finally(() => {
                      isDescriptionInFlight = false;
                      processDescriptionQueue();
                  });
          }

            async function requestDescription(side, photoDataUrl, viewportSnapshot, options = {}) {
                const state = descriptionState[side];
                if (!state) {
                    return;
                }

                const label = side === 'you' ? 'You' : 'Me';

                if (!window.DESCRIPTION_API_URL) {
                    setDescriptionState(side, 'error', `${label} description API is not configured. Set window.DESCRIPTION_API_URL before capturing.`);
                    return;
                }

                setDescriptionState(side, 'loading', WAITING_FOR_DESCRIPTION_MESSAGE, WAITING_FOR_DESCRIPTION_MESSAGE);

        let renderedViewportDataUrl;

        try {
            renderedViewportDataUrl = await createViewportDataUrl(photoDataUrl, viewportSnapshot);
        } catch (renderError) {
            let message;
            if (renderError?.name === 'SelectionAreaError') {
                message = `${label} description failed: adjust the white bounding box so it fully covers the subject, then try again.`;
            } else if (renderError?.name === 'ViewportNotReadyError') {
                message = `${label} description failed: viewing area is still loading. Hold steady and try again once the photo stabilizes.`;
            } else if (renderError?.name === 'ViewportScaleError') {
                message = `${label} description failed: unable to align the zoomed image. Re-center the photo and retry.`;
            } else {
                message = `${label} description failed: unable to render the framed view (${renderError?.message || 'unknown error.'})`;
            }
            setDescriptionState(side, 'error', message);
            const error = new Error(renderError?.message || 'Viewport rendering failed.');
            error.name = 'ViewportRenderingError';
            error.cause = renderError;
            throw error;
        }

                const controller = new AbortController();
                const timeoutId = window.setTimeout(() => controller.abort(), DESCRIPTION_API_TIMEOUT_MS);

                try {
                    const response = await fetch(window.DESCRIPTION_API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            role: side,
                            image: renderedViewportDataUrl,
                            viewport: viewportSnapshot,
                            reason: options.reason || 'interaction',
                            signature: options.signature || null
                        }),
                        signal: controller.signal
                    });

                    if (!response.ok) {
                        const errorText = await response.text().catch(() => '');
                        throw new Error(errorText || `HTTP ${response.status}`);
                    }

                    const payload = await response.json();
                    const statusFlag = typeof payload?.status === 'string'
                        ? payload.status.trim().toLowerCase()
                        : null;
                    const descriptionText = typeof payload?.description === 'string'
                        ? payload.description.trim()
                        : '';

                    if (statusFlag === 'ok' && descriptionText) {
                        setDescriptionState(side, 'success', `${label} description ready.`, descriptionText);
                        return;
                    }

                    if (statusFlag === 'unclear') {
                        const unclearMessage = descriptionText || 'Unclear photo';
                        setDescriptionState(
                            side,
                            'error',
                            `${label} description unavailable: subject not clear. Retake a closer photo.`,
                            unclearMessage
                        );
                        return;
                    }

                    throw new Error('API response did not include a usable description.');
                } catch (error) {
                    if (error?.name !== 'ViewportRenderingError') {
                        const message = error?.name === 'AbortError'
                            ? `${label} description request timed out after ${Math.round(DESCRIPTION_API_TIMEOUT_MS / 1000)}s.`
                            : `${label} description failed: ${error?.message || 'Unknown error.'}`;
                        setDescriptionState(side, 'error', message);
                    }
                    throw error;
                } finally {
                    window.clearTimeout(timeoutId);
                }
            }

        let backStream = null;
        let isBackFrozen = false;
          let isBackActive = false;
          let backInitializationTimeoutId = null;

        // Selfie camera state
        let selfieStream = null;
        let isSelfieFrozen = false;
        let isSelfieActive = false;

        let isOpeningBackCamera = false;
        let isOpeningSelfieCamera = false;
        const CAMERA_RELEASE_TIMEOUT_MS = 500;

        function showError(message) {
            if (typeof message === 'string') {
                errorMessage.textContent = message;
            }
            errorMessage.classList.remove('warning');
            errorMessage.classList.add('active');
        }

        function showWarning(message) {
            if (typeof message === 'string') {
                errorMessage.textContent = message;
            }
            errorMessage.classList.add('active', 'warning');
            console.warn(message);
        }

        function hideError() {
            errorMessage.classList.remove('active');
            errorMessage.classList.remove('warning');
        }

        function stopStream(stream) {
            if (!stream) {
                return;
            }
            stream.getTracks().forEach(track => track.stop());
        }

        function waitForTrackToEnd(track, timeoutMs = CAMERA_RELEASE_TIMEOUT_MS) {
            if (!track || track.readyState === 'ended') {
                return Promise.resolve();
            }

            return new Promise(resolve => {
                const cleanup = () => {
                    track.removeEventListener('ended', handleEnded);
                    window.clearTimeout(timerId);
                    resolve();
                };

                const handleEnded = () => {
                    cleanup();
                };

                const timerId = window.setTimeout(cleanup, timeoutMs);
                track.addEventListener('ended', handleEnded, { once: true });
            });
        }

        async function stopAllCamerasAndWait(timeoutMs = CAMERA_RELEASE_TIMEOUT_MS) {
            const tracks = [];

            if (backStream) {
                tracks.push(...backStream.getTracks());
            }

            if (selfieStream) {
                tracks.push(...selfieStream.getTracks());
            }

            stopAllCameras();

            if (!tracks.length) {
                return;
            }

            await Promise.all(tracks.map(track => waitForTrackToEnd(track, timeoutMs)));
        }

        async function applyZoomSetting(stream, targetZoom) {
            const track = stream?.getVideoTracks()[0];

            if (!track) {
                return { success: false, reason: 'No video track available.' };
            }

            if (typeof track.getCapabilities !== 'function') {
                const warning = 'Zoom capability is not available on this device.';
                console.warn(warning);
                return { success: true, appliedZoom: null, warning };
            }

            const capabilities = track.getCapabilities();
            const zoomCapabilities = capabilities?.zoom;

            if (!zoomCapabilities) {
                const warning = 'Zoom control is not supported for this camera.';
                console.warn(warning);
                return { success: true, appliedZoom: null, warning };
            }

            const { min, max } = zoomCapabilities;

            if (typeof min !== 'number' || typeof max !== 'number') {
                const warning = 'Zoom range information is unavailable for this camera.';
                console.warn(warning);
                return { success: true, appliedZoom: null, warning };
            }

            let desiredZoom;

            if (targetZoom === 'min') {
                desiredZoom = min;
            } else if (targetZoom === 'max') {
                desiredZoom = max;
            } else if (typeof targetZoom === 'number') {
                desiredZoom = Math.min(max, Math.max(min, targetZoom));
                if (targetZoom > max + 1e-3) {
                    return { success: false, reason: `Requested zoom ${targetZoom}x exceeds supported maximum ${max.toFixed(2)}x.` };
                }
            } else {
                return { success: false, reason: 'Invalid zoom configuration requested.' };
            }

            try {
                await track.applyConstraints({ advanced: [{ zoom: desiredZoom }] });
                return { success: true, appliedZoom: desiredZoom };
            } catch (primaryError) {
                try {
                    await track.applyConstraints({ zoom: desiredZoom });
                    return { success: true, appliedZoom: desiredZoom };
                } catch (secondaryError) {
                    const fallbackError = secondaryError || primaryError;
                    return { success: false, reason: fallbackError?.message || 'Unable to adjust zoom for this camera.' };
                }
            }
        }

          async function waitForZoomToSettle(track, targetZoom, tolerance = 0.05, timeoutMs = 1500) {
              if (!track || typeof track.getSettings !== 'function') {
                  return { success: false, reason: 'Zoom settings cannot be read for this camera.' };
              }

              if (typeof targetZoom !== 'number') {
                  return { success: false, reason: 'Invalid target zoom provided.' };
              }

              const startTime = performance.now();

              while (performance.now() - startTime < timeoutMs) {
                  const settings = track.getSettings();
                  if (settings && typeof settings.zoom === 'number') {
                      const currentZoom = settings.zoom;
                      if (Math.abs(currentZoom - targetZoom) <= tolerance) {
                          return { success: true, appliedZoom: currentZoom };
                      }
                  }
                  await new Promise(resolve => setTimeout(resolve, 50));
              }

              const finalSettings = track.getSettings?.();
              const reportedZoom = typeof finalSettings?.zoom === 'number'
                  ? finalSettings.zoom.toFixed(2) + 'x'
                  : 'an unknown level';

              return {
                  success: false,
                  reason: `Camera never reported ${targetZoom.toFixed(2)}x zoom (last reported ${reportedZoom}).`
              };
          }

          function waitForVideoMetadata(videoElement) {
              if (videoElement.readyState >= HTMLMediaElement.HAVE_METADATA) {
                  return Promise.resolve();
              }

              return new Promise((resolve, reject) => {
                  const handleLoaded = () => {
                      videoElement.removeEventListener('error', handleError);
                      resolve();
                  };

                  const handleError = (event) => {
                      videoElement.removeEventListener('loadedmetadata', handleLoaded);
                      reject(event?.error || new Error('Failed to load camera metadata.'));
                  };

                  videoElement.addEventListener('loadedmetadata', handleLoaded, { once: true });
                  videoElement.addEventListener('error', handleError, { once: true });
              });
          }

        async function activateBackStream(stream) {
            const zoomResult = await applyZoomSetting(stream, BACK_TARGET_ZOOM);
            if (!zoomResult.success) {
                  stopStream(stream);
                      showError('Back camera (requires 2x zoom): ' + zoomResult.reason);
                return false;
            }

            const track = stream.getVideoTracks()[0];
          initializeZoomStateFromTrack('back', track);

              backStream = stream;
              backVideoElement.srcObject = backStream;

            try {
                const shouldVerifyZoom = typeof zoomResult.appliedZoom === 'number';
                const expectedZoom = shouldVerifyZoom
                    ? zoomResult.appliedZoom
                    : BACK_TARGET_ZOOM;

                const zoomVerificationPromise = shouldVerifyZoom
                    ? waitForZoomToSettle(track, expectedZoom)
                    : Promise.resolve({ success: true, appliedZoom: zoomResult.appliedZoom });

                const [zoomSettled] = await Promise.all([
                    zoomVerificationPromise,
                    waitForVideoMetadata(backVideoElement)
                ]);

                if (shouldVerifyZoom && !zoomSettled.success) {
                      stopStream(stream);
                      backVideoElement.srcObject = null;
                          showError('Back camera (requires 2x zoom): ' + zoomSettled.reason);
                    return false;
                }

                if (shouldVerifyZoom) {
                    const verifiedZoom = typeof zoomSettled.appliedZoom === 'number'
                        ? zoomSettled.appliedZoom
                        : (typeof track.getSettings === 'function' ? track.getSettings().zoom : undefined);

                    if (typeof verifiedZoom === 'number' && Math.abs(verifiedZoom - expectedZoom) > 0.05) {
                          stopStream(stream);
                          backVideoElement.srcObject = null;
                              showError('Back camera (requires 2x zoom): Device reported ' + verifiedZoom.toFixed(2) + 'x zoom.');
                        return false;
                    }
                      const backState = interactionState.back;
                      if (backState) {
                          backState.streamZoom.current = typeof verifiedZoom === 'number' ? verifiedZoom : expectedZoom;
                      }
                  } else if (typeof zoomResult.appliedZoom === 'number') {
                      const backState = interactionState.back;
                      if (backState) {
                          backState.streamZoom.current = zoomResult.appliedZoom;
                      }
                }

                const videoWidth = backVideoElement.videoWidth;
                const videoHeight = backVideoElement.videoHeight;
                if (videoWidth && videoHeight) {
                    updateCameraHalfAspect('back', videoWidth / videoHeight);
                } else {
                    console.warn('Back camera metadata unavailable after initialization.');
                }
            } catch (error) {
                  console.error('Back camera stream failed to become ready:', error);
                    stopStream(stream);
                    backVideoElement.srcObject = null;
                      showError('Back camera (requires 2x zoom): Unable to load camera stream.');
                  return false;
              }

            if (zoomResult.warning) {
                showWarning('Back camera: ' + zoomResult.warning + ' Displaying the default field of view.');
            } else {
                hideError();
            }
            backCameraHalf.classList.add('initializing');
            hideDefaultPhoto('back');
            backVideoElement.classList.add('active');
          const backState = interactionState.back;
          if (backState) {
                backState.lastTap = null;
                backState.lastSubmittedSignature = null;
                clearMovementDebounce('back');
          }
            isBackActive = true;
            backPlaceholder.classList.add('hidden');

              if (backInitializationTimeoutId !== null) {
                  clearTimeout(backInitializationTimeoutId);
              }

              backInitializationTimeoutId = window.setTimeout(() => {
                  backCameraHalf.classList.remove('initializing');
                  backInitializationTimeoutId = null;
              }, 1000);

            return true;
        }

        async function activateSelfieStream(stream) {
            selfieStream = stream;
            selfieVideoElement.srcObject = selfieStream;
            const selfieTrack = selfieStream?.getVideoTracks()[0];

            const zoomResult = await applyZoomSetting(selfieStream, SELFIE_ZOOM_MODE);
            if (!zoomResult.success) {
                stopStream(selfieStream);
                selfieStream = null;
                selfieVideoElement.srcObject = null;
                showError('Selfie camera: ' + zoomResult.reason);
                return false;
            }
          initializeZoomStateFromTrack('selfie', selfieTrack);

            let zoomWarningMessage = zoomResult.warning
                ? 'Selfie camera: ' + zoomResult.warning + ' Displaying the default field of view.'
                : null;

              try {
                  const shouldVerifyZoom = typeof zoomResult.appliedZoom === 'number';
                  const expectedZoom = shouldVerifyZoom
                      ? zoomResult.appliedZoom
                      : undefined;

                  const zoomVerificationPromise = shouldVerifyZoom
                      ? waitForZoomToSettle(selfieTrack, expectedZoom)
                      : Promise.resolve({ success: true, appliedZoom: zoomResult.appliedZoom });

                  const [zoomSettled] = await Promise.all([
                      zoomVerificationPromise,
                      waitForVideoMetadata(selfieVideoElement)
                  ]);

                  if (shouldVerifyZoom && !zoomSettled.success) {
                      const warning = 'Selfie camera: ' + zoomSettled.reason + ' Displaying the default field of view.';
                      console.warn('Selfie camera zoom verification failed:', zoomSettled.reason);
                      zoomWarningMessage = warning;
                  }
              } catch (error) {
                  console.error('Selfie camera stream failed to become ready:', error);
                  stopStream(selfieStream);
                  selfieStream = null;
                  selfieVideoElement.srcObject = null;
                  showError('Selfie camera: Unable to load camera stream.');
                  return false;
              }

              const videoWidth = selfieVideoElement.videoWidth;
              const videoHeight = selfieVideoElement.videoHeight;
              if (videoWidth && videoHeight) {
                  updateCameraHalfAspect('selfie', videoWidth / videoHeight);
              } else {
                  console.warn('Selfie camera metadata unavailable after initialization.');
              }

                if (typeof zoomResult.appliedZoom === 'number') {
                    const selfieState = interactionState.selfie;
                    if (selfieState) {
                        selfieState.streamZoom.current = zoomResult.appliedZoom;
                    }
                }

            if (zoomWarningMessage) {
                showWarning(zoomWarningMessage);
            } else {
                hideError();
            }
            hideDefaultPhoto('selfie');
            selfieVideoElement.classList.add('active');
          const selfieState = interactionState.selfie;
          if (selfieState) {
                selfieState.lastTap = null;
                selfieState.lastSubmittedSignature = null;
                clearMovementDebounce('selfie');
          }
            isSelfieActive = true;
            selfiePlaceholder.classList.add('hidden');

            return true;
        }

        function checkCameraSupport() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showError('Camera API is not supported in this browser.');
                return false;
            }
            return true;
        }

        function stopAllCameras() {
            // Stop back camera
            if (backStream) {
                stopStream(backStream);
                backStream = null;
            }
            backVideoElement.srcObject = null;
            backVideoElement.classList.remove('active');
              backCameraHalf.classList.remove('initializing');
            isBackActive = false;
          resetPointerTracking('back');
          const backState = interactionState.back;
          if (backState) {
              backState.zoomSupported = false;
              backState.streamZoom.min = 1;
              backState.streamZoom.max = 1;
              backState.streamZoom.current = 1;
        backState.lastSubmittedSignature = null;
          }

              if (backInitializationTimeoutId !== null) {
                  clearTimeout(backInitializationTimeoutId);
                  backInitializationTimeoutId = null;
              }
            
            // Stop selfie camera
            if (selfieStream) {
                stopStream(selfieStream);
                selfieStream = null;
            }
            selfieVideoElement.srcObject = null;
            selfieVideoElement.classList.remove('active');
            isSelfieActive = false;
          resetPointerTracking('selfie');
          const selfieState = interactionState.selfie;
          if (selfieState) {
              selfieState.zoomSupported = false;
              selfieState.streamZoom.min = 1;
              selfieState.streamZoom.max = 1;
              selfieState.streamZoom.current = 1;
        selfieState.lastSubmittedSignature = null;
          }
            
            if (!isBackFrozen) {
                showDefaultPhoto('back');
            }

            if (!isSelfieFrozen) {
                showDefaultPhoto('selfie');
            }
            
        }

        async function openBackCamera() {
            if (isOpeningBackCamera) {
                console.warn('Back camera start request ignored: initialization already in progress.');
                return;
            }

            isOpeningBackCamera = true;

            if (!checkCameraSupport()) {
                isOpeningBackCamera = false;
                return;
            }

            try {
                await stopAllCamerasAndWait();

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            facingMode: 'environment',
                            width: { ideal: 1920 },
                            height: { ideal: 1080 },
                              advanced: [{ zoom: BACK_TARGET_ZOOM }]
                        }
                    });
                    const activated = await activateBackStream(stream);
                    if (!activated) {
                        return;
                    }
                    
                } catch (error) {
                    console.error('Error accessing back camera:', error);
                    
                    if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                        showError('Back camera access was denied.');
                    } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                        showError('No back camera found.');
                    } else {
                        try {
                            const stream = await navigator.mediaDevices.getUserMedia({
                                video: { facingMode: 'environment' }
                            });
                            const activated = await activateBackStream(stream);
                            if (!activated) {
                                return;
                            }
                        } catch (retryError) {
                            console.warn('Back camera fallback without zoom constraint failed, retrying with generic video request.', retryError);
                            try {
                                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                                const activated = await activateBackStream(stream);
                                if (!activated) {
                                    return;
                                }
                            } catch (finalRetryError) {
                                console.error('Final attempt to access back camera failed:', finalRetryError);
                                showError('Failed to access back camera.');
                            }
                        }
                    }
                }
            } finally {
                isOpeningBackCamera = false;
            }
        }

        async function openSelfieCamera() {
            if (isOpeningSelfieCamera) {
                console.warn('Selfie camera start request ignored: initialization already in progress.');
                return;
            }

            isOpeningSelfieCamera = true;

            if (!checkCameraSupport()) {
                isOpeningSelfieCamera = false;
                return;
            }

            try {
                await stopAllCamerasAndWait();

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            facingMode: 'user',
                            width: { ideal: 1920 },
                            height: { ideal: 1080 }
                        }
                    });
                    const activated = await activateSelfieStream(stream);
                    if (!activated) {
                        return;
                    }
                    
                } catch (error) {
                    console.error('Error accessing selfie camera:', error);

                    const errorMessageText = error?.message || '';
                    const shouldRetryAfterRelease = error?.name === 'NotReadableError'
                        || /could not start video source/i.test(errorMessageText);

                    if (shouldRetryAfterRelease) {
                        await stopAllCamerasAndWait();
                        await new Promise(resolve => setTimeout(resolve, 150));

                        try {
                            const retryStream = await navigator.mediaDevices.getUserMedia({
                                video: {
                                    facingMode: 'user',
                                    width: { ideal: 1920 },
                                    height: { ideal: 1080 }
                                }
                            });
                            const activated = await activateSelfieStream(retryStream);
                            if (activated) {
                                return;
                            }
                        } catch (retryError) {
                            console.error('Selfie camera retry after release failed:', retryError);
                        }
                    }
                    
                    try {
                        const devices = await navigator.mediaDevices.enumerateDevices();
                        const videoDevices = devices.filter(device => device.kind === 'videoinput');
                        
                        if (videoDevices.length > 1) {
                            const backTrack = backStream?.getVideoTracks()[0];
                            const backDeviceId = backTrack?.getSettings().deviceId;
                            
                            const frontDevice = videoDevices.find(device => 
                                device.deviceId && device.deviceId !== backDeviceId
                            );
                            
                            if (frontDevice && frontDevice.deviceId) {
                                const stream = await navigator.mediaDevices.getUserMedia({
                                    video: { deviceId: { exact: frontDevice.deviceId } }
                                });
                                const activated = await activateSelfieStream(stream);
                                if (!activated) {
                                    return;
                                }
                                return;
                            }
                        }
                        
                        const stream = await navigator.mediaDevices.getUserMedia({ 
                            video: { facingMode: 'user' } 
                        });
                        const activated = await activateSelfieStream(stream);
                        if (!activated) {
                            return;
                        }
                        
                    } catch (retryError) {
                        console.error('Retry failed:', retryError);
                        try {
                            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                            const activated = await activateSelfieStream(stream);
                            if (!activated) {
                                return;
                            }
                        } catch (finalError) {
                            console.error('Final attempt failed:', finalError);
                            showError('Selfie camera: ' + (finalError.message || 'Unable to access front camera.'));
                        }
                    }
                }
            } finally {
                isOpeningSelfieCamera = false;
            }
        }

        // Back camera functions

          function captureBackPhoto() {
            if (!backStream || !isBackActive) return;

            const videoWidth = backVideoElement.videoWidth;
            const videoHeight = backVideoElement.videoHeight;

            if (!videoWidth || !videoHeight) {
                console.warn('Back camera metadata unavailable; capture skipped.');
                return;
            }

            updateCameraHalfAspect('back', videoWidth / videoHeight);

            const canvas = document.createElement('canvas');
            canvas.width = videoWidth;
            canvas.height = videoHeight;

            const ctx = canvas.getContext('2d');

            ctx.drawImage(
                backVideoElement,
                0, 0, videoWidth, videoHeight,
                0, 0, canvas.width, canvas.height
            );

        const photoDataUrl = canvas.toDataURL('image/png');
        displayPhotoForSide('you', photoDataUrl);
        
        isBackFrozen = true;
        
        // Stop camera
        stopAllCameras();
        }

          function resetBackCamera() {
            if (!isBackFrozen) return;
            
            backCapturedPhoto.classList.remove('active');
            showDefaultPhoto('back');
            isBackFrozen = false;
              resetDescriptionState('you');
        }

        // Selfie camera functions
        function captureSelfiePhoto() {
            if (!selfieStream || !isSelfieActive) return;

            const videoWidth = selfieVideoElement.videoWidth;
            const videoHeight = selfieVideoElement.videoHeight;
            if (!videoWidth || !videoHeight) {
                console.warn('Selfie camera metadata unavailable; capture skipped.');
                return;
            }

            updateCameraHalfAspect('selfie', videoWidth / videoHeight);

            const canvas = document.createElement('canvas');
            canvas.width = videoWidth;
            canvas.height = videoHeight;

            const ctx = canvas.getContext('2d');

            ctx.drawImage(
                selfieVideoElement,
                0, 0, videoWidth, videoHeight,
                0, 0, canvas.width, canvas.height
            );

        const photoDataUrl = canvas.toDataURL('image/png');
        displayPhotoForSide('me', photoDataUrl);
        
        isSelfieFrozen = true;
        
        // Stop camera
        stopAllCameras();
        }

          function resetSelfieCamera() {
            if (!isSelfieFrozen) return;
            
            selfieCapturedPhoto.classList.remove('active');
            showDefaultPhoto('selfie');
            isSelfieFrozen = false;
              resetDescriptionState('me');
        }

        backCameraHalf.addEventListener('pointerdown', (event) => handlePointerDownOnHalf('back', event));
        backCameraHalf.addEventListener('pointermove', (event) => handlePointerMoveOnHalf('back', event));
        backCameraHalf.addEventListener('pointerup', (event) => handlePointerUpOnHalf('back', event));
        backCameraHalf.addEventListener('pointercancel', (event) => handlePointerCancelOnHalf('back', event));
        backCameraHalf.addEventListener('pointerleave', (event) => handlePointerCancelOnHalf('back', event));

        selfieCameraHalf.addEventListener('pointerdown', (event) => handlePointerDownOnHalf('selfie', event));
        selfieCameraHalf.addEventListener('pointermove', (event) => handlePointerMoveOnHalf('selfie', event));
        selfieCameraHalf.addEventListener('pointerup', (event) => handlePointerUpOnHalf('selfie', event));
        selfieCameraHalf.addEventListener('pointercancel', (event) => handlePointerCancelOnHalf('selfie', event));
        selfieCameraHalf.addEventListener('pointerleave', (event) => handlePointerCancelOnHalf('selfie', event));

        // Cleanup when page is closed
          window.addEventListener('beforeunload', () => {
            stopAllCameras();
        });

          attachResubmitHandlers(youResubmitButton, 'you');
          attachResubmitHandlers(meResubmitButton, 'me');
          attachUploadHandler(youUploadButton, youUploadInput, 'you');
        attachUploadHandler(meUploadButton, meUploadInput, 'me');
        setupSelectionInteractions('back');
        setupSelectionInteractions('selfie');
        updateSelectionStyles('back');
        updateSelectionStyles('selfie');

        function renderAppVersion() {
            if (!versionDisplay) {
                return;
            }
            const label = `v${APP_VERSION}`;
            versionDisplay.textContent = label;
            versionDisplay.setAttribute('aria-label', `Application version ${APP_VERSION}`);
        }

        renderAppVersion();

            resetDescriptionState('you');
            resetDescriptionState('me');

          // Configure the API endpoint for Netlify Function
          window.DESCRIPTION_API_URL = '/.netlify/functions/describe';
    </script>
</body>
</html>
