<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Camera</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            width: 100vw;
            height: 100vh;
        }

        .camera-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
        }

        #videoElement {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            transform-origin: center center;
        }

        #capturedPhoto {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: center center;
        }

        #capturedPhoto.active {
            display: block;
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            pointer-events: none;
            z-index: 10;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }

        .crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .crosshair::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 100;
            max-width: 80%;
        }

        .error-message.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="camera-container">
        <video id="videoElement" autoplay playsinline></video>
        <img id="capturedPhoto" alt="Captured photo">
        <div class="crosshair"></div>
        <div id="errorMessage" class="error-message"></div>
    </div>

    <script>
        const videoElement = document.getElementById('videoElement');
        const capturedPhoto = document.getElementById('capturedPhoto');
        const errorMessage = document.getElementById('errorMessage');
        const cameraContainer = document.querySelector('.camera-container');
        
        let stream = null;
        let isZooming = false;
        let zoomAnimationId = null;
        let touchStartTime = null;
        let currentZoom = 1;
        let isFrozen = false;

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.add('active');
        }

        function hideError() {
            errorMessage.classList.remove('active');
        }

        function checkCameraSupport() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showError('Camera API is not supported in this browser.');
                return false;
            }
            return true;
        }

        async function openCamera() {
            if (!checkCameraSupport()) {
                return;
            }

            hideError();

            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                });

                videoElement.srcObject = stream;
                
            } catch (error) {
                console.error('Error accessing camera:', error);
                
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    showError('Camera access was denied. Please allow camera permissions.');
                } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    showError('No camera found.');
                } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                    showError('Camera is already in use by another application.');
                } else {
                    // Retry with simpler constraints
                    try {
                        stream = await navigator.mediaDevices.getUserMedia({ video: true });
                        videoElement.srcObject = stream;
                    } catch (retryError) {
                        showError('Failed to access camera.');
                    }
                }
            }
        }

        function startZoom() {
            if (isZooming || isFrozen) return;
            
            isZooming = true;
            touchStartTime = Date.now();
            currentZoom = 1;
            videoElement.style.transition = 'none';
            
            const animateZoom = () => {
                if (!isZooming) return;
                
                const elapsed = Date.now() - touchStartTime;
                const progress = Math.min(elapsed / 3000, 1); // 3 seconds total
                currentZoom = 1 + (progress * 3); // 1x to 4x
                
                videoElement.style.transform = `scale(${currentZoom})`;
                
                if (progress < 1) {
                    zoomAnimationId = requestAnimationFrame(animateZoom);
                } else {
                    // At max zoom, ensure currentZoom is exactly 4
                    currentZoom = 4;
                    videoElement.style.transform = `scale(4)`;
                    // Continue animation loop to keep transform updated
                    zoomAnimationId = requestAnimationFrame(animateZoom);
                }
            };
            
            animateZoom();
        }

        function stopZoom() {
            // Always capture, even if not actively zooming (e.g., at max zoom)
            if (zoomAnimationId) {
                cancelAnimationFrame(zoomAnimationId);
                zoomAnimationId = null;
            }
            
            isZooming = false;
            capturePhoto();
        }

        function capturePhoto() {
            if (!stream) return;

            // Capture the visible portion at full video resolution
            // When zoomed to currentZoom, we see 1/currentZoom of the video
            const videoWidth = videoElement.videoWidth;
            const videoHeight = videoElement.videoHeight;
            
            // Calculate the visible portion based on zoom (in video pixels)
            const sourceWidth = videoWidth / currentZoom;
            const sourceHeight = videoHeight / currentZoom;
            const sourceX = (videoWidth - sourceWidth) / 2;
            const sourceY = (videoHeight - sourceHeight) / 2;
            
            // Create canvas at screen size to maintain aspect ratio
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const canvas = document.createElement('canvas');
            canvas.width = screenWidth;
            canvas.height = screenHeight;
            
            const ctx = canvas.getContext('2d');
            
            // Draw the visible portion from video, scaled to screen size
            // This captures exactly what was visible at full quality
            ctx.drawImage(
                videoElement,
                sourceX, sourceY, sourceWidth, sourceHeight,
                0, 0, canvas.width, canvas.height
            );

            const photoDataUrl = canvas.toDataURL('image/png');
            capturedPhoto.src = photoDataUrl;
            // Display at 1x scale - it matches exactly what was shown
            capturedPhoto.style.transform = 'scale(1)';
            capturedPhoto.classList.add('active');
            videoElement.style.display = 'none';
            
            isFrozen = true;
        }

        function resetCamera() {
            if (!isFrozen) return;
            
            capturedPhoto.classList.remove('active');
            videoElement.style.display = 'block';
            videoElement.style.transition = 'transform 0.3s ease-out';
            videoElement.style.transform = 'scale(1)';
            currentZoom = 1;
            isFrozen = false;
            isZooming = false;
            
            if (zoomAnimationId) {
                cancelAnimationFrame(zoomAnimationId);
                zoomAnimationId = null;
            }
        }

        // Touch event handlers
        cameraContainer.addEventListener('touchstart', (e) => {
            e.preventDefault();
            
            if (isFrozen) {
                resetCamera();
                // Start zooming immediately after reset
                setTimeout(() => startZoom(), 50);
            } else {
                startZoom();
            }
        });

        cameraContainer.addEventListener('touchend', (e) => {
            e.preventDefault();
            
            if (!isFrozen) {
                stopZoom();
            }
        });

        cameraContainer.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            
            if (!isFrozen) {
                stopZoom();
            }
        });

        // Prevent default touch behaviors
        cameraContainer.addEventListener('touchmove', (e) => {
            e.preventDefault();
        });

        // Auto-open camera on page load
        window.addEventListener('load', () => {
            openCamera();
        });

        // Cleanup when page is closed
        window.addEventListener('beforeunload', () => {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
        });
    </script>
</body>
</html>
